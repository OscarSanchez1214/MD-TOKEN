"use client";

import { useEffect, useState } from "react";
import { MiniKit } from "@worldcoin/minikit-js";
import { ethers } from "ethers";

const MD_TOKEN_ADDRESS = "0x6335c1F2967A85e98cCc89dA0c87e672715284dB";
const ERC20_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
];

// Intenta recuperar la dirección del usuario usando MiniKit (varios nombres usados habitualmente)
async function getAddressFromMiniKit(): Promise<string | null> {
  if (!MiniKit || !MiniKit.commandsAsync) return null;
  const candidateMethods = [
    "getAccount",
    "getAddress",
    "getWalletAddress",
    "getCurrentAddress",
    "getWallet",
    "getUserAddress",
    "getUser",
  ];
  for (const m of candidateMethods) {
    try {
      // @ts-ignore - dinámica
      const fn = MiniKit.commandsAsync[m];
      if (typeof fn === "function") {
        const res = await fn();
        // normalizar: puede devolver string o objeto { address: '0x...' }
        if (!res) continue;
        if (typeof res === "string") return res;
        if (res.address) return res.address;
        if (res?.wallet?.address) return res.wallet.address;
      }
    } catch (e) {
      // ignora y prueba siguiente
    }
  }
  return null;
}

// Obtiene un provider: primero try window.ethereum, si no usar RPC desde env
function getProvider(): ethers.providers.Provider {
  if (typeof (window as any).ethereum !== "undefined") {
    return new ethers.providers.Web3Provider((window as any).ethereum);
  }
  const rpc = process.env.NEXT_PUBLIC_RPC_URL || (window as any).__WORLD_RPC__; // fallback posible
  if (rpc) return new ethers.providers.JsonRpcProvider(rpc);
  throw new Error(
    "No hay provider disponible. Agrega NEXT_PUBLIC_RPC_URL con un RPC de World Chain o prueba desde World App con provider expuesto."
  );
}

export const WalletSection = () => {
  const [address, setAddress] = useState<string | null>(null);
  const [balance, setBalance] = useState<string | null>(null);
  const [decimals, setDecimals] = useState<number | null>(null);
  const [symbol, setSymbol] = useState<string>("MD");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // paso: obtener dirección (MiniKit -> window.ethereum -> null)
  const obtainAddress = async () => {
    setError(null);
    try {
      let addr: string | null = null;
      // primero MiniKit
      try {
        addr = await getAddressFromMiniKit();
      } catch (e) {
        // ignore
      }
      // fallback a window.ethereum
      if (!addr && typeof (window as any).ethereum !== "undefined") {
        const provider = new ethers.providers.Web3Provider((window as any).ethereum);
        const accounts = await provider.listAccounts();
        addr = accounts && accounts.length ? accounts[0] : null;
      }
      setAddress(addr);
      return addr;
    } catch (e: any) {
      setError("Error obteniendo address: " + String(e?.message ?? e));
      return null;
    }
  };

  // paso: leer saldo on-chain
  const fetchBalance = async (addr?: string) => {
    setError(null);
    setLoading(true);
    try {
      const user = addr || (await obtainAddress());
      if (!user) {
        setError("No se pudo obtener la dirección del usuario.");
        setLoading(false);
        return;
      }

      const provider = getProvider();
      const token = new ethers.Contract(MD_TOKEN_ADDRESS, ERC20_ABI, provider);

      // leer decimals y symbol
      let tokenDecimals = 18;
      try {
        tokenDecimals = await token.decimals();
        setDecimals(Number(tokenDecimals));
      } catch (e) {
        // fallback a 18
        setDecimals(18);
      }

      try {
        const s = await token.symbol();
        setSymbol(s || "MD");
      } catch {
        // ignore
      }

      const raw: ethers.BigNumber = await token.balanceOf(user);
      const formatted = ethers.utils.formatUnits(raw, tokenDecimals);
      setBalance(formatted);
    } catch (e: any) {
      setError("Error leyendo saldo: " + String(e?.message ?? e));
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // al montar, intentar obtener address y balance
    (async () => {
      try {
        const addr = await obtainAddress();
        await fetchBalance(addr ?? undefined);
      } catch (e) {
        // ignore
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div className="p-4 border rounded shadow-sm">
      <h3 className="text-lg font-semibold mb-2">Cartera</h3>

      <div className="mb-2">
        <strong>Dirección:</strong>
        <div className="text-sm break-all mt-1">
          {address ?? (
            <span className="text-gray-500">No conectada (abre la MiniApp desde World App o configura RPC)</span>
          )}
        </div>
      </div>

      <div className="mb-2">
        <strong>Token:</strong> <span>{symbol} ({MD_TOKEN_ADDRESS})</span>
      </div>

      <div className="mb-4">
        <strong>Saldo:</strong>{" "}
        {loading ? (
          <span>cargando…</span>
        ) : balance !== null ? (
          <span>{balance} {symbol}</span>
        ) : (
          <span className="text-gray-500">—</span>
        )}
      </div>

      {error && <div className="text-red-600 mb-2">Error: {error}</div>}

      <div className="flex gap-2">
        <button
          className="bg-blue-600 text-white px-3 py-2 rounded"
          onClick={() => fetchBalance(address ?? undefined)}
        >
          Refrescar
        </button>

        <button
          className="bg-gray-200 px-3 py-2 rounded"
          onClick={async () => {
            // Forzar re-obtención de address (útil si World App aún no expone la address)
            const a = await obtainAddress();
            if (a) await fetchBalance(a);
          }}
        >
          Reconectar
        </button>
      </div>
    </div>
  );
};

